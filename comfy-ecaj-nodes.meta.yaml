kynetic_meta: "1.0"
agents:
  - _ulid: 01KH4D20YRV8MXAEMAC70AKQQZ
    id: claude
    name: Claude Code Agent
    description: Primary development agent for this project.
    capabilities:
      - code
      - test
      - refactor
      - review
    tools:
      - kspec
      - git
      - uv
    conventions: []
workflows:
  - _ulid: 01KH4D2G8XEYKRQNNZR9HC6S8A
    id: task-work-session
    trigger: manual
    description: Core pattern for working on a task. Full lifecycle from start through PR merge.
    steps:
      - type: check
        content: |-
          Check for existing in_progress or pending_review tasks.
          Use: kspec session start (shows active work first)
          Priority: pending_review > in_progress > ready
        on_fail: Inherit existing work instead of starting new.
      - type: action
        content: |-
          Choose task to work on.
          Use: kspec tasks ready to see available tasks
      - type: check
        content: |-
          Verify work is not already done.
          Check git history and existing code.
        on_fail: Mark task complete with Already implemented reason
      - type: action
        content: |-
          Start the task.
          Use: kspec task start @task
      - type: action
        content: |-
          Work on the task, adding notes as you go.
          Use: kspec task note @task "What you are doing..."
      - type: check
        content: All changes committed
        on_fail: "Commit changes with Task: @task trailer."
      - type: action
        content: |-
          Submit task for review.
          Use: kspec task submit @task
      - type: action
        content: |-
          Create PR.
          Use: /pr skill or gh pr create
  - _ulid: 01KH4D2XWDYBF7V5FW6GA497JC
    id: session-reflect
    trigger: session-end
    description: Structured reflection after work sessions. Surfaces learnings, identifies friction, and
      captures improvements.
    steps:
      - type: action
        content: |-
          Identify what worked well this session.
          Be specific. Consider: workflows, tools, communication, decisions.
      - type: action
        content: |-
          Identify friction points - where things were harder than needed.
          Focus on systemic issues, not one-off mistakes.
      - type: action
        content: |-
          Check if friction points are already tracked.
          Search specs, tasks, AND inbox before proposing new improvements.
      - type: action
        content: |-
          For untracked friction, propose concrete improvements.
          Include: what it would do, how it helps, rough scope.
      - type: decision
        content: Present findings to user - ask about each improvement one at a time
        options:
          - Worth capturing -> proceed to capture
          - Needs refinement -> discuss and refine
          - Not worth it -> skip
          - Done with reflection -> complete workflow
      - type: action
        content: |-
          Capture approved items:
          - Actionable improvements: kspec inbox add
          - Friction patterns: kspec meta observe friction
          - Success patterns: kspec meta observe success
          - Open questions: kspec meta question add
  - _ulid: 01KH4D3C8G9G78XHVVJXB0B874
    id: pr-review-merge
    trigger: pr-merge
    description: Quality gate for reviewing and merging PRs. Ensures all CI passes, reviews addressed,
      and threads resolved before merge.
    steps:
      - type: check
        content: All CI checks complete (none pending or running)
        on_fail: Wait for CI to finish. Do not merge while checks are running.
      - type: check
        content: All CI checks pass (green)
        on_fail: Fix failures, push changes, wait for CI to re-run and pass.
      - type: action
        content: |-
          Read ALL review comments on the PR.
          Use: gh pr view --comments or GitHub UI
      - type: check
        content: All review feedback addressed
        on_fail: Fix each issue raised by reviewers. Push changes and wait for re-review if needed.
      - type: action
        content: |-
          Check for @claude mentions or other requests in comments.
          Complete any actions the PR agent could not.
      - type: check
        content: All requested actions completed
        on_fail: Complete the actions yourself before proceeding.
      - type: check
        content: All review threads resolved in GitHub UI
        on_fail: Click Resolve conversation on each thread after addressing.
      - type: decision
        content: Ready to merge?
        options:
          - Yes - all checks green, all reviews addressed, all threads resolved
          - No - need user approval to merge with known issues
          - Skip - user explicitly said to merge anyway
      - type: action
        content: |-
          Merge the PR.
          Use: gh pr merge (prefer merge commit to preserve trailers)
  - _ulid: 01KH4D3QHJSWS40QETS1K5ER2N
    id: inbox-triage
    trigger: session-start
    description: Systematic processing of inbox items into specs and tasks.
    steps:
      - type: action
        content: |-
          Get context and list inbox items.
          Use: kspec session start --full
          Use: kspec inbox list
      - type: action
        content: |-
          Categorize items by type:
          - Bugs
          - Spec gaps
          - Quick wins
          - Larger features (need plan mode)
          - Delete candidates
      - type: decision
        content: Process each item - is it still relevant?
        options:
          - No -> delete it
          - Yes, spec exists -> promote to task
          - Yes, need spec -> create spec first
          - Unclear -> leave for later
      - type: action
        content: |-
          For behavior changes, follow spec-first approach:
          1. Check if spec covers the change
          2. Create or update spec with AC if needed
          3. Derive task or promote inbox item
  - _ulid: 01KH4D44TWNR22J821DBRS9YPV
    id: local-review
    trigger: manual
    description: Quality enforcement for pre-PR review. Verifies AC coverage with annotations, test
      quality, and test isolation.
    steps:
      - type: action
        content: |-
          Get spec reference and read acceptance criteria.
          Use: kspec item get @spec to see ACs
          Each AC needs test coverage.
      - type: check
        content: |-
          Every AC has test coverage with AC annotation.
          Search tests for: # AC: @spec-ref ac-N
        on_fail: "MUST-FIX: Missing AC coverage is a blocking issue."
      - type: check
        content: |-
          All tests validate real behavior (no fluff tests).
          Tests should fail if the feature breaks.
        on_fail: "MUST-FIX: Identify and flag fluff tests."
      - type: check
        content: |-
          Tests are properly isolated.
          No shared mutable state across tests.
          Fresh fixtures for each test case.
        on_fail: "MUST-FIX: Tests must be properly isolated."
      - type: action
        content: |-
          Report findings.
          List all MUST-FIX issues that block PR creation.
          Non-blocking suggestions can be noted separately.
  - _ulid: 01KH4D4MGKTBM16W1NFT9TMQJS
    id: pr-review-loop
    trigger: loop-pr-review
    description: PR review subagent workflow for loop mode. Runs local review, verifies AC coverage and
      spec alignment, fixes issues, waits for CI, and merges with quality gates.
    steps:
      - type: action
        content: |-
          Run local review workflow first.
          Use: /local-review skill
      - type: check
        content: |-
          Verify all spec ACs linked to task have test coverage.
          Check test files for AC annotations.
        on_fail: Add missing test coverage before continuing.
      - type: check
        content: |-
          Verify implementation matches spec requirements.
          Read spec, read implementation, compare.
        on_fail: Fix misalignment between spec and implementation.
      - type: decision
        content: Evaluate local-review findings.
        options:
          - MUST-FIX issues, can fix -> Fix and continue
          - MUST-FIX issues, cannot fix -> Mark needs_review, EXIT
          - Only advisory issues -> Continue with merge
          - No issues -> Continue with merge
      - type: action
        content: Push changes (if any fixes were made).
      - type: check
        content: |-
          Wait for CI to complete and pass.
          CRITICAL: Re-verify CI after ANY push.
        on_fail: "If CI fails: investigate, fix, push, return to this step."
      - type: action
        content: |-
          Post review summary as PR comment.
          Use: gh pr comment
      - type: action
        content: |-
          Follow PR review merge gates.
          Use: kspec workflow start @pr-review-merge
      - type: check
        content: Verify PR was successfully merged.
        on_fail: Check for conflicts or protection rules.
      - type: action
        content: |-
          Mark task completed with PR reference.
          Use: kspec task complete @task --reason "Merged in PR #N"
  - _ulid: 01KH4W1R540NJ1MYZ1XAM9D7KR
    id: spec-plan-design
    trigger: manual
    description: Research and design phase for plan-to-spec translation. Explore codebase, clarify
      requirements, design approach, review for completeness and spec gaps. Concludes with choosing
      import or manual execution path.
    steps:
      - type: action
        content: >-
          Explore and research the codebase.


          Understand: existing specs/items in the domain, related patterns, current code structure,
          traits that may apply.


          Use /spec skill knowledge for spec types, AC format, and trait reference.


          Focus on what already exists to avoid duplication. Use parallel searches for efficiency.
        inputs:
          - name: feature_description
            description: What you are planning to build
            type: string
      - type: action
        content: >-
          Clarify requirements with the user.


          Present structured questions with clear options. One question at a time - do not batch
          multiple questions.


          Each question should resolve a specific design choice or scope decision.


          Continue until no open questions remain. Capture answers as they inform the design.
      - type: action
        content: >-
          Design the approach.


          Synthesize exploration findings, user answers, and requirements into a concrete design.


          Propose: spec items needed, AC for each, applicable traits, parent placement, and task
          structure.


          Write the design to a durable artifact (plan file or document) so it survives session
          boundaries.
      - type: check
        content: Design passes holistic review
        on_fail: >-
          Address review feedback - fix gaps, refine AC, add missing traits. Iterate until review
          passes.


          Review for: (1) completeness - gaps or missing scenarios, (2) consistency - specs align
          with existing patterns, (3) spec coverage - proper types, AC quality, trait applicability
          per /spec skill, (4) edge cases.


          Exit criteria: design written to file, all review issues addressed.
      - type: decision
        content: Choose execution path based on the reviewed plan
        options:
          - Import path - write structured plan document and auto-generate (3+ specs, batch creation)
          - Manual path - create specs incrementally with kspec commands (1-2 specs, quick additions)
  - _ulid: 01KH4W2EVRR14Z55XSGY646P3C
    id: spec-plan-import
    trigger: manual
    description: Execute plan via structured document import - write document, choose module, preview,
      import, review traits, validate, start work. Follows @spec-plan-design. Import auto-creates
      plan record with status active.
    steps:
      - type: action
        content: >-
          Write or finalize plan document.


          Format: # Title, ## Specs with YAML code block (title required, optional: slug, type,
          parent, AC, traits),

          ## Tasks with derive_from_specs flag, ## Implementation Notes (plain text).
        inputs:
          - name: plan_file_path
            description: Path to the markdown plan file
            type: string
      - type: action
        content: >-
          Choose target module.


          Use: kspec item list --type module


          If no suitable module exists, create one: kspec item add --type module --title "Module
          Name"


          Note the generated reference for the next step.
        inputs:
          - name: module_ref
            description: Reference to the target module
            type: ref
      - type: action
        content: |-
          Preview with dry-run.
          Use: kspec plan import <path> --module @module --dry-run
          Review: spec count, task count, errors, skipped items.
      - type: check
        content: Dry-run output acceptable - all specs valid, parents resolved, no circular deps, at least
          one spec found
        on_fail: |-
          Fix document based on error type:
          (1) YAML parse errors - fix syntax
          (2) Missing parent refs - add parent to plan or verify existing ref
          (3) Circular deps - restructure parent chain
          (4) Missing required fields - add title to spec entries
          Re-run dry-run.
      - type: action
        content: >-
          Run actual import.


          Use: kspec plan import <path> --module @module


          For re-imports of revised documents, add --update to update existing specs.


          Import auto-creates plan record (status: active) with derived_specs and derived_tasks
          linked.


          Verify: kspec plan get @plan-slug
      - type: action
        content: >-
          Review and apply traits.


          Use: kspec trait list for available traits.


          For each created spec, consider cross-cutting concerns (json-output, dry-run,
          error-guidance, semantic-exit-codes, shadow-commit, filterable-list).


          Apply any not already declared in plan document: kspec item trait add @spec @trait


          Note: traits add inherited AC automatically.
      - type: check
        content: Validate references - kspec validate --refs
        on_fail: Fix reference issues (dangling parent refs, missing spec_ref/plan_ref links)
      - type: action
        content: |-
          Start implementation.
          Pick first task from: kspec plan get @plan --json (derived_tasks).
          Use: kspec task start @task
          Then follow /task-work for task lifecycle.
  - _ulid: 01KH4W30QQFDJS6WF58B47PB0J
    id: spec-plan-manual
    trigger: manual
    description: Execute plan via incremental spec creation - create plan record, find parent, create
      specs with AC, review traits, derive tasks with plan linking, validate, start work. Follows
      @spec-plan-design.
    steps:
      - type: action
        content: >-
          Create plan record.


          Use: kspec plan add --title "Plan Title" --content "Brief description of what is being
          planned" --status approved


          Status approved because you are committing to the work.
        inputs:
          - name: plan_ref
            description: The created plan reference
            type: ref
      - type: action
        content: >-
          Find parent and create spec items.


          Search: kspec search "<keyword>", kspec item list --tag <domain>, kspec item get @parent


          If no suitable parent exists, create a module: kspec item add --type module --title
          "Module Name"


          Create specs: kspec item add --under @parent --title "Title" --type feature --slug slug


          Repeat for each spec.
        inputs:
          - name: parent_ref
            description: Reference to the parent item
            type: ref
      - type: action
        content: >-
          Add acceptance criteria.


          For each spec: kspec item ac add @spec --given "precondition" --when "action" --then
          "expected result"


          Each AC independently testable. 3-5 AC per spec is typical.


          Cover happy path and key edge cases.
      - type: action
        content: |-
          Review and apply traits.
          Use: kspec trait list to browse available traits.
          Consider cross-cutting concerns for the spec type.
          Apply: kspec item trait add @spec @trait
          Traits add inherited AC automatically.
      - type: action
        content: >-
          Derive tasks and link to plan.


          Preview: kspec derive @spec --dry-run


          Create: kspec derive @spec (recursive by default, creates task tree with dependencies)


          Link each derived task to plan: kspec task set @task --plan-ref @plan


          Set plan active: kspec plan set @plan --status active


          Add implementation notes: kspec task note @task "Implementation approach: ..."


          Note: task set --plan-ref creates a one-way link (task->plan). The plan derived_tasks
          array is only auto-updated by kspec plan derive and kspec plan import, not by manual
          linking.
      - type: check
        content: Validate all references - kspec validate --refs. Verify spec_ref and plan_ref resolve
          correctly on tasks.
        on_fail: Fix reference issues
      - type: action
        content: >-
          Verify structure.


          kspec item status @spec shows linked tasks.


          For each task: kspec task get @task confirms plan_ref and spec_ref are set.


          Note: check task-side links (not plan derived_tasks which is not auto-updated in manual
          path).
      - type: action
        content: |-
          Start implementation.
          Use: kspec task start @first-task
          Then follow /task-work for task lifecycle.
  - _ulid: 01KH53VJMS1TPSTYMWCPHJZMTR
    id: session-start
    trigger: session-start
    description: Get context at the beginning of a work session.
    steps:
      - type: action
        content: Run kspec session start to get context
      - type: check
        content: Are there active (in_progress) tasks?
        on_fail: Pick from ready tasks or triage inbox
      - type: action
        content: Review ready tasks and inbox items
      - type: action
        content: Start work on chosen task via kspec task start
  - _ulid: 01KH53VMGSZYW2QG2PQW7PWN99
    id: task-lifecycle
    trigger: task-complete
    description: Complete a task properly with notes and cleanup.
    steps:
      - type: action
        content: Add completion note describing what was done
      - type: action
        content: Run kspec task complete @task --reason "summary"
      - type: check
        content: Are there uncommitted changes?
        on_fail: Commit changes with descriptive message
      - type: action
        content: Review if task unblocked other work
  - _ulid: 01KH53VPSMRZ2H3B3A4F2YXWD0
    id: codebase-audit
    trigger: pre-release
    description: "Comprehensive codebase audit for release readiness. Five-phase workflow: parallel
      exploration (docs, code, config, tests, specs), compilation by severity, interactive triage,
      execution, and summary."
    steps: []
conventions:
  - _ulid: 01KH4D4XBHYX71V8BQF8NVQTA1
    domain: commits
    rules:
      - Use conventional commit format (feat, fix, docs, refactor, test, chore)
      - Include Task trailer when completing task work
      - Include Spec trailer when implementing spec item
      - Keep subject line under 72 characters
    examples: []
  - _ulid: 01KH4D54RSWVY7TE2E8RBV892W
    domain: notes
    rules:
      - Add notes during work, not just at end
      - Include context for decisions made
      - Reference related commits, PRs, or issues
    examples: []
  - _ulid: 01KH509WYHJKSQ1XXE7FYDATA1
    domain: testing
    rules:
      - Every implementation task must include tests covering its spec ACs
      - "Tests must be annotated with # AC: @spec-ref ac-N comments linking to the spec AC they
        cover"
      - The local-review workflow checks for AC annotation coverage before PR
      - Tests must not require a running ComfyUI instance or GPU
    examples: []
observations:
  - _ulid: 01KH5140KRDP91DHZCZ3Z2G0XZ
    type: success
    content: "Parallel subagent research during spec-plan-design: Launching a general-purpose subagent
      for ComfyUI testing research while continuing main conversation was efficient and produced
      comprehensive findings without blocking the planning flow."
    created_at: 2026-02-11T00:20:20.216Z
    author: "@claude"
    resolved: false
    resolution: null
  - _ulid: 01KH5142AKZ0J43JTZ4PZ8BPXY
    type: success
    content: "kspec batch for bulk operations: Using atomic batch to mark 21 tasks eligible and wire 18
      dependency links saved significant time. Atomic rollback on typo was correct behavior and
      caught the error cleanly."
    created_at: 2026-02-11T00:20:21.971Z
    author: "@claude"
    resolved: false
    resolution: null
includes: []
